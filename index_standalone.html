<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PID在线仿真与自动整定</title>
    
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    
    <style>
        /* 全局样式 */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f4f7f9;
            color: #333;
        }

        h1, h3, h4 {
            color: #2c3e50;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
        }

        /* 主容器布局 */
        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        /* 控制区样式 */
        .controls {
            flex: 1;
            min-width: 300px;
            background-color: #ffffff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .controls p {
            margin: 15px 0;
        }

        /* 输入框样式 */
        input[type="number"] {
            width: 80px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        /* 按钮样式 */
        button {
            display: block;
            width: 100%;
            padding: 10px 15px;
            margin-top: 10px;
            border: none;
            border-radius: 5px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        #run-button {
            background-color: #3498db; /* 蓝色 */
        }

        #run-button:hover {
            background-color: #2980b9;
        }

        #autotune-button {
            background-color: #27ae60; /* 绿色 */
        }

        #autotune-button:hover {
            background-color: #229954;
        }

        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }

        /* 绘图区样式 */
        .plot-area {
            flex: 3;
            min-width: 600px;
            background-color: #ffffff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        #plot {
            width: 100%;
            min-height: 500px;
        }

        /* 【UX改进】自整定状态和结果框样式 */
        .status-box, .result-box {
            margin-top: 20px;
            padding: 15px;
            border-radius: 5px;
            border-left: 5px solid;
            opacity: 1;
            transform: scaleY(1);
            transition: opacity 0.4s ease-in-out, transform 0.4s ease-in-out, margin-top 0.4s;
            transform-origin: top;
        }

        /* 【新增】隐藏状态的样式 */
        .hidden {
            opacity: 0;
            transform: scaleY(0);
            height: 0; /* 动画时高度变为0 */
            margin-top: 0;
            padding-top: 0;
            padding-bottom: 0;
            border-width: 0; /* 边框也消失 */
            overflow: hidden;
            transition: opacity 0.4s, transform 0.4s, margin-top 0.4s, padding 0.4s, height 0.4s, border-width 0.4s;
        }

        .status-box {
            background-color: #e7f3fe;
            border-color: #2196F3; /* 蓝色 */
        }

        .result-box {
            background-color: #e8f5e9;
            border-color: #4CAF50; /* 绿色 */
        }

        .result-box h4 {
            margin-top: 0;
        }

        .result-box i {
            font-size: 0.9em;
            color: #555;
        }

        /* 【新增】加载动画 (Spinner) */
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db; /* 与按钮颜色一致 */
            border-radius: 50%;
            width: 25px;
            height: 25px;
            animation: spin 1.5s linear infinite;
            margin-top: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>

<body>

    <h1>PID在线仿真与自动整定器</h1>

    <div class="container">
        <div class="controls">
            <h3>A. 仿真输入区</h3>
            
            <strong>1. 控制器参数 (PID)</strong>
            <p>
                Kc (增益): <input type="number" id="kc" value="1.0" step="0.1">
            </p>
            <p>
                Ti (积分时间,s): <input type="number" id="ti" value="9999" step="0.1"> (9999表示无穷大)
            </p>
            <p>
                Td (微分时间,s): <input type="number" id="td" value="0.0" step="0.1">
            </p>
            
            <strong>2. 被控对象 (Process)</strong>
            <div id="model-selection">
                <input type="radio" id="model1" name="model" value="first_order" checked>
                <label for="model1">一阶对象: 1/(5s+1)</label>
                <br>
                <input type="radio" id="model2" name="model" value="second_order">
                <label for="model2">二阶对象: 25/(s²+3s+25)</label>
            </div>
            
            <p>
                纯滞后 (Delay,s): <input type="number" id="delay" value="0.0" step="0.1">
            </p>

            <h3>B. 仿真控制区</h3>
            <button id="run-button">运行仿真 (手动)</button>
            <button id="autotune-button">参数自动整定 (Auto-Tune)</button>
            
            <div id="autotune-status" class="status-box hidden">
                <p><strong>正在自动整定...</strong></p>
                <p id="autotune-step-info">请稍候...</p> 
                <div class="spinner"></div>
            </div>
            <div id="autotune-results" class="result-box hidden">
                <h4>整定结果:</h4>
                <p id="autotune-result-params"></p>
                <p><i>参数已自动回填，仿真曲线已更新。</i></p>
            </div>

        </div>

        <div class="plot-area">
            <h3>C. 仿真输出区</h3>
            <div id="plot"></div>
        </div>
    </div>

    <script>
        // --- "大脑" (app.js) V8.1 终极UX完美版 ---
        console.log("app.js (大脑) V8.1 终极UX完美版 已加载!");

        // --- 1. 获取HTML元素 ---
        const runButton = document.getElementById("run-button"); const autotuneButton = document.getElementById("autotune-button");
        const plotDiv = document.getElementById("plot"); const kcInput = document.getElementById("kc"); const tiInput = document.getElementById("ti"); const tdInput = document.getElementById("td"); const delayInput = document.getElementById("delay");
        const autotuneStatusDiv = document.getElementById("autotune-status"); const autotuneStepInfo = document.getElementById("autotune-step-info");
        const autotuneResultsDiv = document.getElementById("autotune-results"); const autotuneResultParams = document.getElementById("autotune-result-params");

        // --- 2. 仿真核心参数 & 3. G2模型 ---
        const SIM = { sampleTime: 0.01, totalTime: 50, spStartTime: 5, spStartValue: 0.0, spEndValue: 1.0, };
        const OP_MIN = 0.0; const OP_MAX = 2.0; const PID_N = 10.0;
        const G2 = { Ad: [[0.99876266, 0.00984738], [-0.24618462, 0.96922051]], Bd: [[0.00123734], [0.24618462]], C: [1, 0] };

        // --- 4. 事件监听器 ---
        runButton.addEventListener("click", runSimulation);
        autotuneButton.addEventListener("click", async function () {
            autotuneButton.disabled = true; runButton.disabled = true;
            autotuneResultsDiv.classList.add("hidden");
            autotuneStatusDiv.classList.remove("hidden");
            try {
                const autoTuner = new AutoTuner();
                const bestParams = await autoTuner.runOptimization();
                autotuneStatusDiv.classList.add("hidden");
                await new Promise(resolve => setTimeout(resolve, 400));
                autotuneResultsDiv.classList.remove("hidden");
                const { Kc, Ti } = bestParams;
                autotuneResultParams.innerHTML = `<b>优化结果: Kc=${Kc.toFixed(3)}, Ti=${Ti.toFixed(3)}, Td=0.0</b>`;
                kcInput.value = Kc.toFixed(3); tiInput.value = Ti.toFixed(3); tdInput.value = 0.0;
                runSimulation();
            } catch (error) {
                autotuneStatusDiv.classList.add("hidden");
                alert(`响应优化失败: ${error.message}`);
            } finally {
                autotuneButton.disabled = false; runButton.disabled = false;
            }
        });

        // --- 5. 核心仿真函数 & 6. 辅助工具 ---
        function runSimulation() {
            console.log("开始仿真...");
            const Kc = parseFloat(kcInput.value); const Ti = parseFloat(tiInput.value); const Td = parseFloat(tdInput.value);
            const delayTime = parseFloat(delayInput.value); const selectedModel = document.querySelector('input[name="model"]:checked').value;
            const numSteps = Math.floor(SIM.totalTime / SIM.sampleTime); const delaySteps = Math.round(delayTime / SIM.sampleTime);
            const delayBuffer = new DelayBuffer(delaySteps);
            let timeData = [], spData = [], pvData = [], opData = [];
            let pidState = { integral: 0.0, derivative_filtered: 0.0 };
            let g1_pv_prev = 0.0; let g2_x = [0.0, 0.0]; let pv = 0.0; let pv_prev = 0.0; let op = 0.0;
            for (let k = 0; k < numSteps; k++) {
                let t = k * SIM.sampleTime;
                if (selectedModel === 'first_order') {
                    let a = Math.exp(-SIM.sampleTime / 5.0); let b = 1.0 * (1.0 - a); pv = a * g1_pv_prev + b * op; g1_pv_prev = pv;
                } else {
                    let x_prev = [...g2_x];
                    let x0 = G2.Ad[0][0] * x_prev[0] + G2.Ad[0][1] * x_prev[1] + G2.Bd[0][0] * op;
                    let x1 = G2.Ad[1][0] * x_prev[0] + G2.Ad[1][1] * x_prev[1] + G2.Bd[1][0] * op;
                    g2_x = [x0, x1]; pv = G2.C[0] * g2_x[0];
                }
                let sp = (t >= SIM.spStartTime) ? SIM.spEndValue : SIM.spStartValue;
                let op_raw = calculatePID(pidState, sp, pv, pv_prev, Kc, Ti, Td, OP_MIN, OP_MAX);
                let op_delayed = delayBuffer.push(op_raw);
                timeData.push(t); spData.push(sp); pvData.push(pv); opData.push(op_delayed);
                pv_prev = pv; op = op_delayed;
            }
            const sp_trace = { x: timeData, y: spData, mode: 'lines', name: 'SP (设定值)', line: { color: 'black', dash: 'dash' } };
            const pv_trace = { x: timeData, y: pvData, mode: 'lines', name: 'PV (过程值)', line: { color: 'blue', width: 2 } };
            const op_trace = { x: timeData, y: opData, mode: 'lines', name: 'OP (控制器输出)', line: { color: 'red' }, yaxis: 'y2' };
            const layout = { title: 'PID 仿真响应曲线', xaxis: { title: '时间 (s)' }, yaxis: { title: 'PV / SP', range: [-0.2, 1.5] }, yaxis2: { title: 'OP', overlaying: 'y', side: 'right', range: [-0.1, OP_MAX + 0.1] }, legend: { x: 0.7, y: 0.95 } };
            Plotly.newPlot(plotDiv, [sp_trace, pv_trace, op_trace], layout);
        }

        class DelayBuffer {
            constructor(delaySteps) { this.buffer = new Array(delaySteps).fill(0.0); }
            push(value) { if (this.buffer.length === 0) return value; const delayedValue = this.buffer.shift(); this.buffer.push(value); return delayedValue; }
        }

        function calculatePID(state, sp, pv, pv_prev, Kc, Ti, Td, op_min, op_max) {
            let dt = SIM.sampleTime; let error = sp - pv; let P_out = Kc * error; let I_out = (Ti > 0 && Ti < 9998) ? state.integral : 0.0; let D_out = 0.0;
            if (Td > 0) {
                let T_f = Td / PID_N; if (T_f < dt) T_f = dt; let a = T_f / (T_f + dt);
                let derivative_raw = (pv - pv_prev) / dt;
                state.derivative_filtered = a * state.derivative_filtered + (1 - a) * derivative_raw;
                D_out = -Kc * Td * state.derivative_filtered;
            } else { state.derivative_filtered = 0.0; }
            let op_unclamped = P_out + I_out + D_out; let op_clamped = Math.max(op_min, Math.min(op_max, op_unclamped));
            if (Ti > 0 && Ti < 9998) {
                let is_winding_up = (op_clamped >= op_max && error > 0); let is_winding_down = (op_clamped <= op_min && error < 0);
                if (!is_winding_up && !is_winding_down) { state.integral += (Kc / Ti) * error * dt; }
            } else { state.integral = 0.0; }
            return op_clamped;
        }

        // --- 7. 响应优化器核心实现 V8.1 ---
        class AutoTuner {
            constructor() {
                this.delayTime = parseFloat(delayInput.value); this.selectedModel = document.querySelector('input[name="model"]:checked').value;
                this.maxIterations = 100; this.tolerance = 1e-6;
            }

            async runOptimization() {
                return new Promise(async (resolve, reject) => {
                    try {
                        const stage1StartTime = Date.now();
                        autotuneStepInfo.innerHTML = `步骤 1/2: 识别近似模型...`;
                        await this.forceUIRender();
                        const initialGuess = this._getInitialGuess();
                        console.log("Initial Guess:", initialGuess);
                        const stage1Duration = Date.now() - stage1StartTime;
                        if (stage1Duration < 800) await new Promise(res => setTimeout(res, 800 - stage1Duration));
                        autotuneStepInfo.innerHTML = `步骤 2/2: 进行响应优化...`;
                        await this.forceUIRender();
                        const bestPoint = await this._performOptimization(initialGuess);
                        resolve({ Kc: bestPoint.kc, Ti: bestPoint.ti });
                    } catch (e) { reject(e); }
                });
            }

            async _performOptimization(initialGuess) {
                let p1 = { kc: initialGuess.Kc, ti: initialGuess.Ti, cost: Infinity };
                let p2 = { kc: initialGuess.Kc * 1.5, ti: initialGuess.Ti, cost: Infinity };
                let p3 = { kc: initialGuess.Kc, ti: initialGuess.Ti * 0.7, cost: Infinity };
                let simplex = [p1, p2, p3];
                for (let p of simplex) { p.cost = this._evaluateCost(p.kc, p.ti); }
                let overallBest = simplex.sort((a,b)=>a.cost-b.cost)[0];
                let noImprovementCount = 0;
                for (let i = 0; i < this.maxIterations; i++) {
                    simplex.sort((a, b) => a.cost - b.cost);
                    let b = simplex[0], g = simplex[1], w = simplex[2];
                    if (b.cost < overallBest.cost) { overallBest = { ...b }; noImprovementCount = 0; } else { noImprovementCount++; }
                    autotuneStepInfo.innerHTML = `步骤 2/2: 优化迭代中... (${i + 1}/${this.maxIterations})<br>当前最优成本: ${overallBest.cost.toExponential(3)}`;
                    await this.forceUIRender(10);
                    if (Math.abs(b.cost - w.cost) < this.tolerance || noImprovementCount > 20) {
                        if(noImprovementCount > 20) console.log("优化停滞，提前终止。");
                        else console.log(`优化收敛于第 ${i+1} 次迭代。`);
                        break;
                    }
                    if (noImprovementCount > 15) {
                        console.log("陷入局部最优，进行随机重启...");
                        simplex[1] = { kc: overallBest.kc * (1 + Math.random() - 0.5), ti: overallBest.ti * (1 + Math.random() - 0.5) };
                        simplex[2] = { kc: overallBest.kc * (1 + Math.random() - 0.5), ti: overallBest.ti * (1 + Math.random() - 0.5) };
                        simplex[1].cost = this._evaluateCost(simplex[1].kc, simplex[1].ti);
                        simplex[2].cost = this._evaluateCost(simplex[2].kc, simplex[2].ti);
                        noImprovementCount = 0;
                        continue;
                    }
                    let centroid = { kc: (b.kc + g.kc) / 2, ti: (b.ti + g.ti) / 2 };
                    let reflected = { kc: centroid.kc + 1.0 * (centroid.kc - w.kc), ti: centroid.ti + 1.0 * (centroid.ti - w.ti) };
                    reflected.cost = this._evaluateCost(reflected.kc, reflected.ti);
                    if (reflected.cost < g.cost && reflected.cost >= b.cost) { simplex[2] = reflected; continue; }
                    if (reflected.cost < b.cost) {
                        let expanded = { kc: centroid.kc + 2.0 * (reflected.kc - centroid.kc), ti: centroid.ti + 2.0 * (reflected.ti - centroid.ti) };
                        expanded.cost = this._evaluateCost(expanded.kc, expanded.ti);
                        simplex[2] = expanded.cost < reflected.cost ? expanded : reflected; continue;
                    }
                    let contracted = { kc: centroid.kc + 0.5 * (w.kc - centroid.kc), ti: centroid.ti + 0.5 * (w.ti - centroid.ti) };
                    contracted.cost = this._evaluateCost(contracted.kc, contracted.ti);
                    if (contracted.cost < w.cost) { simplex[2] = contracted; continue; }
                    simplex[1] = { kc: b.kc + 0.5 * (g.kc - b.kc), ti: b.ti + 0.5 * (g.ti - b.ti) };
                    simplex[2] = { kc: b.kc + 0.5 * (w.kc - b.kc), ti: b.ti + 0.5 * (w.ti - b.ti) };
                    simplex[1].cost = this._evaluateCost(simplex[1].kc, simplex[1].ti);
                    simplex[2].cost = this._evaluateCost(simplex[2].kc, simplex[2].ti);
                }
                return overallBest;
            }

            _evaluateCost(Kc, Ti) {
                if (Kc <= 0.01 || Ti <= 0.05) return Infinity;
                let sp_vec = [], pv_vec = [], op_vec = [];
                const delaySteps = Math.round(this.delayTime / SIM.sampleTime); const delayBuffer = new DelayBuffer(delaySteps);
                let pidState = { integral: 0.0, derivative_filtered: 0.0 };
                let g1_pv_prev = 0.0; let g2_x = [0.0, 0.0]; let pv = 0.0; let pv_prev = 0.0; let op = 0.0;
                const numSteps = Math.floor(SIM.totalTime / SIM.sampleTime);
                for (let k = 0; k < numSteps; k++) {
                    let t = k * SIM.sampleTime;
                    if (this.selectedModel === 'first_order') {
                        let a = Math.exp(-SIM.sampleTime / 5.0); let b = 1.0 * (1.0 - a); pv = a * g1_pv_prev + b * op; g1_pv_prev = pv;
                    } else {
                        let x_prev = [...g2_x];
                        let x0 = G2.Ad[0][0] * x_prev[0] + G2.Ad[0][1] * x_prev[1] + G2.Bd[0][0] * op;
                        let x1 = G2.Ad[1][0] * x_prev[0] + G2.Ad[1][1] * x_prev[1] + G2.Bd[1][0] * op;
                        g2_x = [x0, x1]; pv = G2.C[0] * g2_x[0];
                    }
                    let sp = (t >= SIM.spStartTime) ? SIM.spEndValue : SIM.spStartValue;
                    let op_raw = calculatePID(pidState, sp, pv, pv_prev, Kc, Ti, 0.0, OP_MIN, OP_MAX);
                    op = delayBuffer.push(op_raw);
                    sp_vec.push(sp); pv_vec.push(pv); op_vec.push(op); pv_prev = pv;
                }
                let ita_error = 0, overshoot = 0, op_change = 0, settling_time_cost = 0;
                const startIndex = Math.floor(SIM.spStartTime / SIM.sampleTime); let settled = false;
                for (let i = startIndex; i < numSteps; i++) {
                    let error = sp_vec[i] - pv_vec[i];
                    let time_since_step = (i - startIndex) * SIM.sampleTime;
                    ita_error += time_since_step * Math.abs(error) * SIM.sampleTime;
                    if (error < -0.01) { overshoot = Math.max(overshoot, -error); }
                    if (i > startIndex) { op_change += Math.abs(op_vec[i] - op_vec[i - 1]); }
                    if (!settled && Math.abs(error) < 0.02) { settled = true; }
                    if (!settled) { settling_time_cost += SIM.sampleTime; }
                }
                if (pv_vec.some(v => isNaN(v) || Math.abs(v) > 5)) return Infinity;
                const cost = ita_error * 1.0 + overshoot * 20.0 + settling_time_cost * 0.5 + op_change * 0.1;
                return cost;
            }
            
            async forceUIRender(delay = 0) { await new Promise(resolve => setTimeout(resolve, delay)); }

            _getInitialGuess() {
                const stepResponseData = this._performStepTest();
                const model = this._identifyModel(stepResponseData);
                return this._calculateInitialParams(model);
            }

            _performStepTest() {
                const stepTime=2.0, stepStartOP=0.4, stepEndOP=0.6; let pvData = [];
                const delaySteps = Math.round(this.delayTime / SIM.sampleTime); const delayBuffer = new DelayBuffer(delaySteps);
                let g1_pv_prev = 0.0; let g2_x = [0.0, 0.0]; let pv = 0.0; let op;
                const numSteps = Math.floor(SIM.totalTime / SIM.sampleTime);
                for (let k = 0; k < numSteps; k++) {
                    let t = k * SIM.sampleTime;
                    let current_op = (t >= stepTime) ? stepEndOP : stepStartOP;
                    op = delayBuffer.push(current_op);
                    if (this.selectedModel === 'first_order') {
                        let a = Math.exp(-SIM.sampleTime / 5.0); let b = 1.0 * (1.0 - a); pv = a * g1_pv_prev + b * op; g1_pv_prev = pv;
                    } else {
                        let x_prev = [...g2_x];
                        let x0 = G2.Ad[0][0] * x_prev[0] + G2.Ad[0][1] * x_prev[1] + G2.Bd[0][0] * op;
                        let x1 = G2.Ad[1][0] * x_prev[0] + G2.Ad[1][1] * x_prev[1] + G2.Bd[1][0] * op;
                        g2_x = [x0, x1]; pv = G2.C[0] * g2_x[0];
                    }
                    pvData.push(pv);
                }
                return pvData;
            }

            _identifyModel(pvData) {
                const stepTime=2.0, stepStartOP=0.4, stepEndOP=0.6;
                const delta_OP = stepEndOP - stepStartOP; const stepStartIndex = Math.floor(stepTime / SIM.sampleTime);
                const pv_start = pvData[stepStartIndex - 2];
                const pv_end_segment = pvData.slice(Math.floor(pvData.length * 0.8));
                const pv_end = pv_end_segment.reduce((a, b) => a + b, 0) / pv_end_segment.length;
                const delta_PV = pv_end - pv_start;
                if (Math.abs(delta_OP) < 1e-6 || Math.abs(delta_PV) < 1e-6) throw new Error("阶跃响应变化过小。");
                const Kp = delta_PV / delta_OP; let maxSlope = 0; let maxSlopeIndex = -1;
                for (let i = stepStartIndex; i < pvData.length -1; i++) {
                    const slope = (pvData[i] - pvData[i - 1]) / SIM.sampleTime;
                    if (slope > maxSlope) { maxSlope = slope; maxSlopeIndex = i; }
                }
                if (maxSlopeIndex === -1) throw new Error("未能找到响应曲线的上升段。");
                const pv_at_max_slope = pvData[maxSlopeIndex]; const t_at_max_slope = maxSlopeIndex * SIM.sampleTime;
                const t_intersect = t_at_max_slope - (pv_at_max_slope - pv_start) / maxSlope;
                const Theta = Math.max(0, t_intersect - stepTime); const Tau = delta_PV / maxSlope;
                return { Kp, Tau, Theta };
            }

            _calculateInitialParams(model) {
                const { Kp, Tau, Theta } = model;
                let Kc, Ti;
                if (Theta / Tau < 0.1 || Tau <= 0) {
                    const Lambda = Math.max(0.8 * Tau, 1.2 * Theta);
                    Kc = (1 / Kp) * Tau / (Lambda + Theta); Ti = Tau;
                } else {
                    Kc = (1 / Kp) * (Tau / Theta) * (0.9 + Theta / (12 * Tau));
                    Ti = Theta * (30 * Tau + 3 * Theta) / (9 * Tau + 20 * Theta);
                }
                return { Kc: Math.max(0.05, Kc), Ti: Math.max(0.1, Ti) };
            }
        }
        
        // 页面加载后自动运行一次仿真
        window.onload = runSimulation;
    </script>

    <footer style="text-align: center; margin-top: 30px; color: #888; font-size: 0.9em;">
        <p>&copy; 2025 太原理工大学 化学与化工学院 周文晋. All Rights Reserved.</p>
        <p>本仿真平台仅供教学演示使用，未经许可，请勿用于商业目的。</p>
    </footer>

</body>
</html>