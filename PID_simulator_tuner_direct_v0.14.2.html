<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PID在线仿真与自动整定</title>
    
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    
    <style>
        /* [样式表 - 保持 V0.14.0 风格] */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f4f7f9;
            color: #333;
        }

        h1, h3, h4 {
            color: #2c3e50;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
        }

        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .controls {
            flex: 1;
            min-width: 300px;
            background-color: #ffffff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .controls p {
            margin: 15px 0;
        }

        input[type="number"] {
            width: 80px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        
        input[type="number"]:disabled {
            background-color: #f0f0f0;
            color: #999;
        }


        button {
            display: block;
            width: 100%;
            padding: 10px 15px;
            margin-top: 10px;
            border: none;
            border-radius: 5px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        #run-button {
            background-color: #3498db;
        }

        #run-button:hover {
            background-color: #2980b9;
        }

        #autotune-button {
            background-color: #27ae60;
        }

        #autotune-button:hover {
            background-color: #229954;
        }

        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }

        .plot-area {
            flex: 3;
            min-width: 600px;
            background-color: #ffffff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        #plot {
            width: 100%;
            min-height: 500px;
        }

        .status-box, .result-box {
            margin-top: 20px;
            padding: 15px;
            border-radius: 5px;
            border-left: 5px solid;
            opacity: 1;
            transform: scaleY(1);
            transition: opacity 0.4s ease-in-out, transform 0.4s ease-in-out, margin-top 0.4s;
            transform-origin: top;
        }

        .hidden {
            opacity: 0;
            transform: scaleY(0);
            height: 0;
            margin-top: 0;
            padding-top: 0;
            padding-bottom: 0;
            border-width: 0;
            overflow: hidden;
            transition: opacity 0.4s, transform 0.4s, margin-top 0.4s, padding 0.4s, height 0.4s, border-width 0.4s;
        }

        .status-box {
            background-color: #e7f3fe;
            border-color: #2196F3;
        }

        .result-box {
            background-color: #eceff1; 
            border-color: #607d8b;     
        }

        .result-box h4 {
            margin-top: 0;
        }

        .result-box i {
            font-size: 0.9em;
            color: #555;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            animation: spin 1.5s linear infinite;
            margin-top: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>

<body>

    <h1>PID在线仿真与自动整定器 v0.14.2</h1>

    <div class="container">
        <div class="controls">
            <h3>A. 仿真输入区</h3>
            
            <strong>1. 控制器参数 (PID)</strong>
            <p>
                Kc (增益): <input type="number" id="kc" value="1.0" step="0.1">
            </p>
            <p>
                Ti (积分时间,s): <input type="number" id="ti" value="5.0" step="0.1" min="0.01" disabled>
                <input type="checkbox" id="ti-infinite" style="margin-left: 10px;" checked>
                <label for="ti-infinite" style="cursor: pointer; user-select: none;">关闭积分</label>
            </p>
            <p>
                Td (微分时间,s): <input type="number" id="td" value="0.0" step="0.1" min="0.0" disabled>
                <input type="checkbox" id="td-infinite" style="margin-left: 10px;" checked>
                <label for="td-infinite" style="cursor: pointer; user-select: none;">关闭微分</label>
            </p>
            
            <strong>2. 被控对象 (Process)</strong>
            <div id="model-selection">
                <input type="radio" id="model1" name="model" value="first_order" checked>
                <label for="model1">一阶对象: 1/(5s+1)</label>
                <br>
                <input type="radio" id="model2" name="model" value="second_order">
                <label for="model2">二阶对象: 25/(s²+3s+25)</label>
                <br>
                <input type="radio" id="model3" name="model" value="heat_exchanger">
                <label for="model3" style="color: #d35400; font-weight: bold;">换热器: 1.2/(10s+1)</label>
            </div>
            
            <p>
                纯滞后 (Delay,s): <input type="number" id="delay" value="0.0" step="0.1">
            </p>

            <strong>3. 仿真设置</strong>
            <p>
                仿真时间 (s): <input type="number" id="sim-time" value="50" step="1" min="10">
            </p>


            <h3>B. 仿真控制区</h3>
            <button id="run-button">运行仿真 (手动)</button>
            <button id="autotune-button">参数自动整定 (Auto-Tune)</button>
            
            <div id="autotune-status" class="status-box hidden">
                <p><strong>正在自动整定...</strong></p>
                <p id="autotune-step-info">请稍候...</p> 
                <div class="spinner"></div>
            </div>
            
            <div id="autotune-results" class="result-box hidden">
                <h4>参数结果:</h4>
                <p id="autotune-result-params"></p>
                <p><i>...</i></p>
            </div>

        </div>

        <div class="plot-area">
            <h3>C. 仿真输出区</h3>
            <div id="plot"></div>
        </div>
    </div>

    <script>
        // --- "大脑" (app.js) V14.2 终极修正版 ---
        console.log("app.js (大脑) V14.2 终极修正版 已加载!");

        // --- 1. 获取HTML元素 ---
        const runButton = document.getElementById("run-button"); 
        const autotuneButton = document.getElementById("autotune-button");
        const plotDiv = document.getElementById("plot"); 
        const kcInput = document.getElementById("kc"); 
        const tiInput = document.getElementById("ti"); 
        const tdInput = document.getElementById("td"); 
        const delayInput = document.getElementById("delay");
        const tiInfiniteCheckbox = document.getElementById("ti-infinite");
        const tdInfiniteCheckbox = document.getElementById("td-infinite");
        const autotuneStatusDiv = document.getElementById("autotune-status"); 
        const autotuneStepInfo = document.getElementById("autotune-step-info");
        const autotuneResultsDiv = document.getElementById("autotune-results"); 
        const autotuneResultParams = document.getElementById("autotune-result-params");
        const simTimeInput = document.getElementById("sim-time"); 
        const model1Radio = document.getElementById("model1");
        const model2Radio = document.getElementById("model2");
        const model3Radio = document.getElementById("model3"); 

        // --- 2. 仿真核心参数 & 3. 模型矩阵 ---
        const SIM = { sampleTime: 0.01, spStartTime: 5 };
        const PID_N = 10.0; 
        const G2 = { Ad: [[0.99876266, 0.00984738], [-0.24618462, 0.96922051]], Bd: [[0.00123734], [0.24618462]], C: [1, 0] };
        
        // V0.14.2: 物理对象常数定义
        const HE_PARAMS = {
            steady_op: 40.0, // 稳态工作点：阀门开度 40%
            steady_pv: 80.0  // 稳态工作点：温度 80°C
        };

        // --- 4. 事件监听器 ---
        runButton.addEventListener("click", runSimulation);
        
        tiInfiniteCheckbox.addEventListener("change", function() {
            tiInput.disabled = tiInfiniteCheckbox.checked;
            hideStaleResults();
        });
        
        tdInfiniteCheckbox.addEventListener("change", function() {
            tdInput.disabled = tdInfiniteCheckbox.checked;
            hideStaleResults();
        });
        
        // 换热器模式切换逻辑：预设参数 + 切换坐标轴
        model3Radio.addEventListener("change", function() {
            if (model3Radio.checked) {
                console.log("切换至换热器模式，加载Z-N预设并更新图表...");
                delayInput.value = "3.0";
                simTimeInput.value = "100";
                
                tiInfiniteCheckbox.checked = true;
                tdInfiniteCheckbox.checked = true;
                tiInput.disabled = true;
                tdInput.disabled = true;
                
                hideStaleResults();
                updatePlotAxes('heat_exchanger');
            }
        });

        model1Radio.addEventListener("change", function() { if(model1Radio.checked) updatePlotAxes('first_order'); hideStaleResults(); });
        model2Radio.addEventListener("change", function() { if(model2Radio.checked) updatePlotAxes('second_order'); hideStaleResults(); });
        delayInput.addEventListener("change", hideStaleResults);

        // 动态更新坐标轴函数
        function updatePlotAxes(modelType) {
             let yAxisTitle = 'PV / SP';
             let yAxisRange = [-0.2, 1.5];
             let yAxis2Title = 'OP';
             let yAxis2Range = [-0.28, 1.1];
             
             if (modelType === 'heat_exchanger') {
                 yAxisTitle = '温度 (°C)';
                 yAxisRange = [78, 85];
                 yAxis2Title = '阀门开度 (%)';
                 yAxis2Range = [-5, 105]; // 0-100% 留点余量
             }
             
             const update = {
                 'yaxis.title.text': yAxisTitle,
                 'yaxis.range': yAxisRange,
                 'yaxis2.title.text': yAxis2Title,
                 'yaxis2.range': yAxis2Range
             };
             Plotly.relayout(plotDiv, update);
        }

        autotuneButton.addEventListener("click", async function () {
            let newTotalTime = parseFloat(simTimeInput.value);
            if (isNaN(newTotalTime) || newTotalTime < 10) { newTotalTime = 50.0; simTimeInput.value = "50"; }

            autotuneButton.disabled = true; runButton.disabled = true;
            autotuneResultsDiv.classList.add("hidden"); 
            autotuneStatusDiv.classList.remove("hidden");
            try {
                const autoTuner = new AutoTuner();
                const bestParams = await autoTuner.runOptimization();
                autotuneStatusDiv.classList.add("hidden");
                await new Promise(resolve => setTimeout(resolve, 400));
                
                autotuneResultsDiv.classList.remove("hidden"); 
                const { Kc, Ti, Td } = bestParams;
                autotuneResultParams.innerHTML = `<b>优化结果: Kc=${Kc.toFixed(3)}, Ti=${Ti.toFixed(3)}, Td=${Td.toFixed(3)}</b>`;
                kcInput.value = Kc.toFixed(3); tiInput.value = Ti.toFixed(3); tdInput.value = Td.toFixed(3);
                
                tiInfiniteCheckbox.checked = false; tiInput.disabled = false;
                if (Td > 0.001) { tdInfiniteCheckbox.checked = false; tdInput.disabled = false; } 
                else { tdInfiniteCheckbox.checked = true; tdInput.disabled = true; }
                
                runSimulation(); 
                
            } catch (error) {
                autotuneStatusDiv.classList.add("hidden");
                alert(`响应优化失败: ${error.message}`);
                initializeChart();
            } finally {
                autotuneButton.disabled = false; runButton.disabled = false;
            }
        });

        function hideStaleResults() {
            if (!autotuneResultsDiv.classList.contains("hidden")) autotuneResultsDiv.classList.add("hidden");
        }

        function initializeChart() {
            const pvColor = '#1f77b4'; const opColor = '#d62728'; const spColor = 'black';
            const sp_trace = { x: [], y: [], mode: 'lines', name: 'SP (设定值)', line: { color: spColor, dash: 'dash' } };
            const pv_trace = { x: [], y: [], mode: 'lines', name: 'PV (过程值)', line: { color: pvColor, width: 2.5 } };
            const op_trace = { x: [], y: [], mode: 'lines', name: 'OP (输出)', line: { color: opColor }, yaxis: 'y2', visible: 'legendonly' };
            
            const layout = { 
                title: 'PID 仿真响应曲线',
                plot_bgcolor: '#f7f7f7', paper_bgcolor: '#ffffff', 
                xaxis: { title: '时间 (s)', gridcolor: '#e0e0e0', gridwidth: 1, griddash: 'dot', range: [0, 50] }, 
                yaxis: { title: { text: 'PV / SP', font: { color: pvColor, size: 14 } }, range: [-0.2, 1.5], tickfont: { color: pvColor }, gridcolor: '#e0e0e0', gridwidth: 1, griddash: 'dot' }, 
                yaxis2: { title: { text: 'OP', font: { color: opColor, size: 14 } }, overlaying: 'y', side: 'right', range: [-0.28, 1.1], tickfont: { color: opColor }, showgrid: false, visible: false }, 
                legend: { x: 0.5, y: 1.1, xanchor: 'center', orientation: 'h' },
                margin: { l: 60, r: 60, t: 80, b: 50 }
            };
            Plotly.newPlot(plotDiv, [sp_trace, pv_trace, op_trace], layout);
            plotDiv.removeAllListeners('plotly_legendclick'); 
            plotDiv.on('plotly_legendclick', function(data) {
                if (data.curveNumber === 2) { 
                    const currentVisibility = data.fullData[2].visible;
                    let newAxisVisibility = (currentVisibility === 'legendonly');
                    Plotly.relayout(plotDiv, { 'yaxis2.visible': newAxisVisibility });
                }
                return true; 
            });
        }


        // --- 5. 核心仿真函数 (V14.2: 包含 Bias 处理逻辑) ---
        function runSimulation() {
            console.log("开始仿真...");

            let Ti;
            if (tiInfiniteCheckbox.checked) { Ti = 9999.0; } 
            else { Ti = parseFloat(tiInput.value); if (Ti <= 0) Ti = 0.01; }

            let Td;
            if (tdInfiniteCheckbox.checked) { Td = 0.0; } 
            else { Td = parseFloat(tdInput.value); if (Td < 0) Td = 0.0; }

            let Kc = parseFloat(kcInput.value); 
            if (Kc <= 0) Kc = 1.0;
            
            const delayTime = parseFloat(delayInput.value); 
            const selectedModel = document.querySelector('input[name="model"]:checked').value;

            // 配置物理环境 (Bias 逻辑)
            let spStartValue, spEndValue, op_min, op_max, op_bias;
            
            if (selectedModel === 'heat_exchanger') {
                spStartValue = HE_PARAMS.steady_pv; // 80.0
                spEndValue = 82.0; 
                op_min = 0.0;
                op_max = 100.0;
                op_bias = HE_PARAMS.steady_op; // 40.0 (修正关键点)
                updatePlotAxes('heat_exchanger');
            } else {
                spStartValue = 0.0; spEndValue = 1.0;
                op_min = 0.0; op_max = 1.0;
                op_bias = 0.0; 
                updatePlotAxes(selectedModel); 
            }

            autotuneStatusDiv.classList.add("hidden");
            autotuneResultsDiv.classList.remove("hidden");
            const resultBoxTitle = autotuneResultsDiv.querySelector("h4");
            if (resultBoxTitle) resultBoxTitle.textContent = "当前手动参数:";
            autotuneResultParams.innerHTML = `<b>Kc=${Kc.toFixed(3)}, Ti=${(Ti > 9998 ? "∞" : Ti.toFixed(3))}, Td=${(Td < 0.001 ? "0.0" : Td.toFixed(3))}</b>`;

            let totalTime = parseFloat(simTimeInput.value);
            if (isNaN(totalTime) || totalTime < 10) totalTime = 50.0;
            const numSteps = Math.floor(totalTime / SIM.sampleTime);

            const delaySteps = Math.round(delayTime / SIM.sampleTime);
            const delayBuffer = new DelayBuffer(delaySteps);
            let timeData = [], spData = [], pvData = [], opData = [];
            let pidState = { integral: 0.0, derivative_filtered: 0.0 };
            
            // 状态初始化 (初始 OP 必须设为 Bias)
            let g1_pv_prev = 0.0; 
            let g2_x = [0.0, 0.0]; 
            let he_pv_deviation_prev = 0.0;
            
            let pv = spStartValue; 
            let pv_prev = pv; 
            let op = op_bias; 
            
            // 预先填充延迟缓冲区
            for(let i=0; i<delaySteps; i++) delayBuffer.push(op_bias);

            for (let k = 0; k < numSteps; k++) {
                let t = k * SIM.sampleTime;
                
                // --- 模型计算 (注意：模型输入需要减去 Bias) ---
                if (selectedModel === 'first_order') {
                    let a = Math.exp(-SIM.sampleTime / 5.0); let b = 1.0 * (1.0 - a); 
                    pv = a * g1_pv_prev + b * op; g1_pv_prev = pv;
                } else if (selectedModel === 'second_order') {
                    let x_prev = [...g2_x];
                    let x0 = G2.Ad[0][0] * x_prev[0] + G2.Ad[0][1] * x_prev[1] + G2.Bd[0][0] * op;
                    let x1 = G2.Ad[1][0] * x_prev[0] + G2.Ad[1][1] * x_prev[1] + G2.Bd[1][0] * op;
                    g2_x = [x0, x1]; pv = G2.C[0] * g2_x[0];
                } else if (selectedModel === 'heat_exchanger') {
                    // 换热器模型：输入是“相对于稳态开度的偏差”
                    let op_deviation = op - HE_PARAMS.steady_op;
                    
                    let alpha = Math.exp(-SIM.sampleTime / 10.0);
                    let beta = 1.2 * (1.0 - alpha); 
                    let pv_dev = alpha * he_pv_deviation_prev + beta * op_deviation;
                    he_pv_deviation_prev = pv_dev;
                    pv = HE_PARAMS.steady_pv + pv_dev;
                }

                let sp = (t >= SIM.spStartTime) ? spEndValue : spStartValue;
                
                // --- PID 计算 (传入 Bias 以防止输出骤降) ---
                let op_raw = calculatePID(pidState, sp, pv, pv_prev, Kc, Ti, Td, op_min, op_max, op_bias);
                
                // 延迟环节
                let op_delayed = delayBuffer.push(op_raw);
                
                timeData.push(t); spData.push(sp); pvData.push(pv); opData.push(op_delayed);
                pv_prev = pv; op = op_delayed; 
            }
            
            const sp_trace = { x: timeData, y: spData };
            const pv_trace = { x: timeData, y: pvData };
            const op_trace = { x: timeData, y: opData };
            
            Plotly.update(plotDiv, {}, { 'xaxis.range': [0, totalTime] }); 
            plotDiv.data[0].x = sp_trace.x; plotDiv.data[0].y = sp_trace.y;
            plotDiv.data[1].x = pv_trace.x; plotDiv.data[1].y = pv_trace.y;
            plotDiv.data[2].x = op_trace.x; plotDiv.data[2].y = op_trace.y;
            Plotly.redraw(plotDiv);
        }

        class DelayBuffer {
            constructor(delaySteps) { this.buffer = new Array(delaySteps).fill(0.0); } 
            push(value) { if (this.buffer.length === 0) return value; const delayedValue = this.buffer.shift(); this.buffer.push(value); return delayedValue; }
        }

        // PID 算法 (支持 Bias 前馈)
        function calculatePID(state, sp, pv, pv_prev, Kc, Ti, Td, op_min, op_max, op_bias) {
            let dt = SIM.sampleTime; let error = sp - pv; 
            
            let P_out = Kc * error; 
            let I_out = (Ti > 0 && Ti < 9998) ? state.integral : 0.0; 
            
            let D_out = 0.0;
            if (Td > 0) {
                let T_f = Td / PID_N; if (T_f < dt) T_f = dt; let a = T_f / (T_f + dt);
                let derivative_raw = (pv - pv_prev) / dt; 
                state.derivative_filtered = a * state.derivative_filtered + (1 - a) * derivative_raw;
                D_out = -Kc * Td * state.derivative_filtered; 
            } else { state.derivative_filtered = 0.0; }
            
            // OP = P + I + D + Bias (核心修正)
            let op_unclamped = P_out + I_out + D_out + op_bias; 
            
            let op_clamped = Math.max(op_min, Math.min(op_max, op_unclamped));
            
            if (Ti > 0 && Ti < 9998) {
                let is_winding_up = (op_clamped >= op_max && error > 0); 
                let is_winding_down = (op_clamped <= op_min && error < 0);
                if (!is_winding_up && !is_winding_down) { state.integral += (Kc / Ti) * error * dt; }
            } else { state.integral = 0.0; }
            
            return op_clamped;
        }

        // --- 7. 响应优化器 (V14.2: 完整算法且适配 Bias) ---
        class AutoTuner {
            constructor() {
                this.delayTime = parseFloat(delayInput.value); 
                this.selectedModel = document.querySelector('input[name="model"]:checked').value;
                this.totalTime = parseFloat(simTimeInput.value);
                if (isNaN(this.totalTime) || this.totalTime < 10) { this.totalTime = 50.0; }
                this.maxIterations = 200; this.tolerance = 1e-7; 
                
                // AutoTuner 物理环境参数同步
                if (this.selectedModel === 'heat_exchanger') {
                    this.spStart = HE_PARAMS.steady_pv; this.spEnd = 82.0;
                    this.opMin = 0.0; this.opMax = 100.0;
                    this.opBias = HE_PARAMS.steady_op; // 40.0
                } else {
                    this.spStart = 0.0; this.spEnd = 1.0;
                    this.opMin = 0.0; this.opMax = 1.0;
                    this.opBias = 0.0;
                }
            }
            
            async runOptimization() {
                return new Promise(async (resolve, reject) => {
                    try {
                        const stage1StartTime = Date.now();
                        autotuneStepInfo.innerHTML = `步骤 1/2: 识别近似模型...`;
                        await this.forceUIRender();
                        const initialGuess = this._getInitialGuess();
                        console.log("Initial Guess (PID):", initialGuess);
                        const stage1Duration = Date.now() - stage1StartTime;
                        if (stage1Duration < 800) await new Promise(res => setTimeout(res, 800 - stage1Duration));
                        autotuneStepInfo.innerHTML = `步骤 2/2: 进行3D响应优化 (Kc, Ti, Td)...`;
                        await this.forceUIRender();
                        const bestPoint = await this._performOptimization(initialGuess);
                        resolve({ Kc: bestPoint.kc, Ti: bestPoint.ti, Td: bestPoint.td });
                    } catch (e) { reject(e); }
                });
            }
            
            async _performOptimization(initialGuess) {
                // 完整单纯形法 (Nelder-Mead)
                let p1 = { kc: initialGuess.Kc, ti: initialGuess.Ti, td: initialGuess.Td, cost: Infinity };
                let p2 = { kc: initialGuess.Kc * 1.5, ti: initialGuess.Ti, td: initialGuess.Td, cost: Infinity };
                let p3 = { kc: initialGuess.Kc, ti: initialGuess.Ti * 0.7, td: initialGuess.Td, cost: Infinity }; 
                let p4 = { kc: initialGuess.Kc, ti: initialGuess.Ti, td: Math.max(0.1, initialGuess.Td * 1.5 + 0.1), cost: Infinity }; 
                let simplex = [p1, p2, p3, p4];

                for (let p of simplex) { p.cost = this._evaluateCost(p.kc, p.ti, p.td); }
                
                let overallBest = simplex.sort((a,b)=>a.cost-b.cost)[0];
                let noImprovementCount = 0;
                
                for (let i = 0; i < this.maxIterations; i++) {
                    simplex.sort((a, b) => a.cost - b.cost);
                    let [b, g1, g2, w] = simplex; 

                    if (b.cost < overallBest.cost) { overallBest = { ...b }; noImprovementCount = 0; } 
                    else { noImprovementCount++; }
                    
                    autotuneStepInfo.innerHTML = `步骤 2/2: 优化迭代中... (${i + 1}/${this.maxIterations})<br>当前最优成本: ${overallBest.cost.toExponential(3)}`;
                    await this.forceUIRender(10);
                    
                    if (Math.abs(b.cost - w.cost) < this.tolerance || noImprovementCount > 50) { break; }
                    if (noImprovementCount > 30) { 
                        simplex[1] = { kc: overallBest.kc * (1 + Math.random() - 0.5), ti: overallBest.ti * (1 + Math.random() - 0.5), td: Math.max(0, overallBest.td * (1 + Math.random() - 0.5)) };
                        simplex[2] = { kc: overallBest.kc * (1 + Math.random() - 0.5), ti: overallBest.ti * (1 + Math.random() - 0.5), td: Math.max(0, overallBest.td * (1 + Math.random() - 0.5)) };
                        simplex[3] = { kc: overallBest.kc * (1 + Math.random() - 0.5), ti: overallBest.ti * (1 + Math.random() - 0.5), td: Math.max(0, overallBest.td * (1 + Math.random() - 0.5)) };
                        for(let p of simplex.slice(1)) { p.cost = this._evaluateCost(p.kc, p.ti, p.td); }
                        noImprovementCount = 0; continue;
                    }
                    
                    let centroid = { 
                        kc: (b.kc + g1.kc + g2.kc) / 3.0, 
                        ti: (b.ti + g1.ti + g2.ti) / 3.0,
                        td: (b.td + g1.td + g2.td) / 3.0
                    };
                    
                    let reflected = { 
                        kc: centroid.kc + 1.0 * (centroid.kc - w.kc), 
                        ti: centroid.ti + 1.0 * (centroid.ti - w.ti),
                        td: centroid.td + 1.0 * (centroid.td - w.td)
                    };
                    reflected.cost = this._evaluateCost(reflected.kc, reflected.ti, reflected.td);
                    
                    if (reflected.cost < g2.cost && reflected.cost >= b.cost) { simplex[3] = reflected; continue; }
                    
                    if (reflected.cost < b.cost) {
                        let expanded = { 
                            kc: centroid.kc + 2.0 * (reflected.kc - centroid.kc), 
                            ti: centroid.ti + 2.0 * (reflected.ti - centroid.ti),
                            td: centroid.td + 2.0 * (reflected.td - centroid.ti)
                        };
                        expanded.cost = this._evaluateCost(expanded.kc, expanded.ti, expanded.td);
                        simplex[3] = expanded.cost < reflected.cost ? expanded : reflected; continue;
                    }
                    
                    let contracted = { 
                        kc: centroid.kc + 0.5 * (w.kc - centroid.kc), 
                        ti: centroid.ti + 0.5 * (w.ti - centroid.ti),
                        td: centroid.td + 0.5 * (w.td - centroid.td)
                    };
                    contracted.cost = this._evaluateCost(contracted.kc, contracted.ti, contracted.td);
                    
                    if (contracted.cost < w.cost) { simplex[3] = contracted; continue; }

                    simplex[1] = { kc: b.kc + 0.5 * (g1.kc - b.kc), ti: b.ti + 0.5 * (g1.ti - b.ti), td: b.td + 0.5 * (g1.td - b.td) };
                    simplex[2] = { kc: b.kc + 0.5 * (g2.kc - b.kc), ti: b.ti + 0.5 * (g2.ti - b.ti), td: b.td + 0.5 * (g2.td - b.td) };
                    simplex[3] = { kc: b.kc + 0.5 * (w.kc - b.kc), ti: b.ti + 0.5 * (w.ti - b.ti), td: b.td + 0.5 * (w.td - b.td) };
                    simplex[1].cost = this._evaluateCost(simplex[1].kc, simplex[1].ti, simplex[1].td);
                    simplex[2].cost = this._evaluateCost(simplex[2].kc, simplex[2].ti, simplex[2].td);
                    simplex[3].cost = this._evaluateCost(simplex[3].kc, simplex[3].ti, simplex[3].td);
                }
                return overallBest;
            }

            _evaluateCost(Kc, Ti, Td) {
                if (Kc <= 0.01 || Ti <= 0.05 || Td < 0) return Infinity; 
                let sp_vec = [], pv_vec = [], op_vec = [];
                const delaySteps = Math.round(this.delayTime / SIM.sampleTime); const delayBuffer = new DelayBuffer(delaySteps);
                
                // 预填充 Bias
                for(let i=0; i<delaySteps; i++) delayBuffer.push(this.opBias);

                let pidState = { integral: 0.0, derivative_filtered: 0.0 };
                let g1_pv_prev = 0.0; let g2_x = [0.0, 0.0]; let he_pv_dev = 0.0;
                let pv = this.spStart; let pv_prev = pv; let op = this.opBias;
                const numSteps = Math.floor(this.totalTime / SIM.sampleTime); 
                
                for (let k = 0; k < numSteps; k++) {
                    let t = k * SIM.sampleTime;
                    
                    // 模型分支 (处理 HE Bias)
                    if (this.selectedModel === 'first_order') {
                         let a = Math.exp(-SIM.sampleTime / 5.0); let b = 1.0 * (1.0 - a); pv = a * g1_pv_prev + b * op; g1_pv_prev = pv;
                    } else if (this.selectedModel === 'second_order') {
                         let x_prev = [...g2_x];
                         let x0 = G2.Ad[0][0] * x_prev[0] + G2.Ad[0][1] * x_prev[1] + G2.Bd[0][0] * op;
                         let x1 = G2.Ad[1][0] * x_prev[0] + G2.Ad[1][1] * x_prev[1] + G2.Bd[1][0] * op;
                         g2_x = [x0, x1]; pv = G2.C[0] * g2_x[0];
                    } else if (this.selectedModel === 'heat_exchanger') {
                         let op_dev = op - this.opBias;
                         let alpha = Math.exp(-SIM.sampleTime / 10.0); let beta = 1.2 * (1.0 - alpha); 
                         let pv_dev_new = alpha * he_pv_dev + beta * op_dev; he_pv_dev = pv_dev_new;
                         pv = HE_PARAMS.steady_pv + pv_dev_new;
                    }

                    let sp = (t >= SIM.spStartTime) ? this.spEnd : this.spStart;
                    // 计算 PID (传入 Bias)
                    let op_raw = calculatePID(pidState, sp, pv, pv_prev, Kc, Ti, Td, this.opMin, this.opMax, this.opBias);
                    op = delayBuffer.push(op_raw);
                    sp_vec.push(sp); pv_vec.push(pv); op_vec.push(op); pv_prev = pv;
                }
                
                let ita_error = 0, overshoot = 0, op_change = 0, settling_time_cost = 0;
                let pv_change = 0; 
                const startIndex = Math.floor(SIM.spStartTime / SIM.sampleTime); let settled = false;
                const span = Math.abs(this.spEnd - this.spStart) || 1.0;

                for (let i = startIndex; i < numSteps; i++) {
                    let error = (sp_vec[i] - pv_vec[i]) / span;
                    let time_since_step = (i - startIndex) * SIM.sampleTime;
                    ita_error += time_since_step * Math.abs(error) * SIM.sampleTime;
                    
                    let raw_error = sp_vec[i] - pv_vec[i];
                    if (this.spEnd > this.spStart) { 
                         if (raw_error < -0.01 * span) overshoot = Math.max(overshoot, Math.abs(raw_error)/span);
                    }
                    
                    if (i > startIndex) { 
                        op_change += Math.abs(op_vec[i] - op_vec[i - 1]) / (this.opMax - this.opMin); 
                        pv_change += Math.abs(pv_vec[i] - pv_vec[i - 1]) / span; 
                    }
                    if (!settled && Math.abs(error) < 0.02) { settled = true; }
                    if (!settled) { settling_time_cost += SIM.sampleTime; }
                }
                if (pv_vec.some(v => isNaN(v) || Math.abs(v) > 1e5)) return Infinity; 
                const cost = ita_error * 1.0 + overshoot * 20.0 + settling_time_cost * 0.5 + (op_change * 1.5) + (pv_change * 0.5);
                return cost;
            }
            
            _getInitialGuess() {
                const stepResponseData = this._performStepTest();
                const model = this._identifyModel(stepResponseData);
                return this._calculateInitialParams(model);
            }
            
            _performStepTest() {
                const stepTime=2.0;
                // 阶跃测试基于稳态工作点 (Bias) + 20%
                const stepStartOP = this.opBias; 
                const stepEndOP = Math.min(this.opMax, this.opBias + 20.0); 
                if (stepEndOP === this.opBias) { stepEndOP = this.opBias - 20.0; } 

                let pvData = [];
                const delaySteps = Math.round(this.delayTime / SIM.sampleTime); const delayBuffer = new DelayBuffer(delaySteps);
                for(let i=0; i<delaySteps; i++) delayBuffer.push(this.opBias);

                let g1_pv_prev = 0.0; let g2_x = [0.0, 0.0]; let he_pv_dev = 0.0;
                let pv = this.spStart; 
                let op;
                const numSteps = Math.floor(this.totalTime / SIM.sampleTime); 
                
                for (let k = 0; k < numSteps; k++) {
                    let t = k * SIM.sampleTime;
                    let current_op = (t >= stepTime) ? stepEndOP : stepStartOP;
                    op = delayBuffer.push(current_op);
                    
                    if (this.selectedModel === 'first_order') {
                        let a = Math.exp(-SIM.sampleTime / 5.0); let b = 1.0 * (1.0 - a); pv = a * g1_pv_prev + b * op; g1_pv_prev = pv;
                    } else if (this.selectedModel === 'second_order') {
                        let x_prev = [...g2_x];
                        let x0 = G2.Ad[0][0] * x_prev[0] + G2.Ad[0][1] * x_prev[1] + G2.Bd[0][0] * op;
                        let x1 = G2.Ad[1][0] * x_prev[0] + G2.Ad[1][1] * x_prev[1] + G2.Bd[1][0] * op;
                        g2_x = [x0, x1]; pv = G2.C[0] * g2_x[0];
                    } else if (this.selectedModel === 'heat_exchanger') {
                         let op_dev = op - this.opBias;
                         let alpha = Math.exp(-SIM.sampleTime / 10.0); let beta = 1.2 * (1.0 - alpha); 
                         let pv_dev_new = alpha * he_pv_dev + beta * op_dev; he_pv_dev = pv_dev_new;
                         pv = HE_PARAMS.steady_pv + pv_dev_new;
                    }
                    pvData.push(pv);
                }
                return { pvData, stepStartOP, stepEndOP };
            }
            
            _identifyModel(data) {
                // 保持 V13.0 标准逻辑
                const { pvData, stepStartOP, stepEndOP } = data;
                const stepTime=2.0; 
                const delta_OP = stepEndOP - stepStartOP; 
                const stepStartIndex = Math.floor(stepTime / SIM.sampleTime);
                
                const pv_start = pvData[stepStartIndex - 2];
                const pv_end_segment = pvData.slice(Math.floor(pvData.length * 0.8));
                const pv_end = pv_end_segment.reduce((a, b) => a + b, 0) / pv_end_segment.length;
                const delta_PV = pv_end - pv_start;
                
                if (Math.abs(delta_OP) < 1e-6 || Math.abs(delta_PV) < 1e-6) throw new Error("阶跃响应变化过小。");
                
                const Kp = delta_PV / delta_OP; 
                let maxSlope = 0; let maxSlopeIndex = -1;
                for (let i = stepStartIndex; i < pvData.length -1; i++) {
                    const slope = (pvData[i] - pvData[i - 1]) / SIM.sampleTime;
                    if (Math.abs(slope) > Math.abs(maxSlope)) { maxSlope = slope; maxSlopeIndex = i; }
                }
                if (maxSlopeIndex === -1) throw new Error("未能找到响应曲线的上升段。");
                const pv_at_max_slope = pvData[maxSlopeIndex]; 
                const t_at_max_slope = maxSlopeIndex * SIM.sampleTime;
                const t_intersect = t_at_max_slope - (pv_at_max_slope - pv_start) / maxSlope;
                const Theta = Math.max(0, t_intersect - stepTime) + this.delayTime; 
                const Tau = delta_PV / maxSlope;
                return { Kp, Tau, Theta };
            }

            _calculateInitialParams(model) {
                // 保持 V13.0 标准逻辑
                let { Kp, Tau, Theta } = model;
                let Kc, Ti, Td;
                if (Theta < 0.01) Theta = 0.01; 
                if (Math.abs(Kp) < 1e-6) Kp = 1e-6;
                if (Tau < 0.01) Tau = 0.01; 
                if (Theta / Tau < 0.15) { 
                    const Lambda = Math.max(0.8 * Tau, 1.5 * Theta); 
                    Kc = (1 / Kp) * Tau / (Lambda + Theta); Ti = Tau; Td = 0.0; 
                } else { 
                    Kc = 1.2 * Tau / (Kp * Theta); Ti = 2.0 * Theta; Td = 0.5 * Theta;
                }
                return { Kc: Math.max(0.05, Kc), Ti: Math.max(0.1, Ti), Td: Math.max(0.0, Td) };
            }
             
            async forceUIRender(delay = 0) { await new Promise(resolve => setTimeout(resolve, delay)); }
        }
        
        window.onload = initializeChart;
    </script>

    <footer style="text-align: center; margin-top: 30px; color: #888; font-size: 0.9em;">
        <p>&copy; 2025 太原理工大学 化学与化工学院过控系 周文晋，张玮. All Rights Reserved.</p>
    </footer>

</body>
</html>