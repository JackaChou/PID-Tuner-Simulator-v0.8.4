<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PID在线仿真与自动整定 v0.9.0</title>
    
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    
    <style>
        /* [样式未修改] */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f4f7f9;
            color: #333;
        }

        h1, h3, h4 {
            color: #2c3e50;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
        }

        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .controls {
            flex: 1;
            min-width: 300px;
            background-color: #ffffff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .controls p {
            margin: 15px 0;
        }

        input[type="number"] {
            width: 80px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        button {
            display: block;
            width: 100%;
            padding: 10px 15px;
            margin-top: 10px;
            border: none;
            border-radius: 5px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        #run-button {
            background-color: #3498db;
        }

        #run-button:hover {
            background-color: #2980b9;
        }

        #autotune-button {
            background-color: #27ae60;
        }

        #autotune-button:hover {
            background-color: #229954;
        }

        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }

        .plot-area {
            flex: 3;
            min-width: 600px;
            background-color: #ffffff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        #plot {
            width: 100%;
            min-height: 500px;
        }

        .status-box, .result-box {
            margin-top: 20px;
            padding: 15px;
            border-radius: 5px;
            border-left: 5px solid;
            opacity: 1;
            transform: scaleY(1);
            transition: opacity 0.4s ease-in-out, transform 0.4s ease-in-out, margin-top 0.4s;
            transform-origin: top;
        }

        .hidden {
            opacity: 0;
            transform: scaleY(0);
            height: 0;
            margin-top: 0;
            padding-top: 0;
            padding-bottom: 0;
            border-width: 0;
            overflow: hidden;
            transition: opacity 0.4s, transform 0.4s, margin-top 0.4s, padding 0.4s, height 0.4s, border-width 0.4s;
        }

        .status-box {
            background-color: #e7f3fe;
            border-color: #2196F3;
        }

        /* --- 【V0.9.0 核心修改】 ---
         * 将结果框从 绿色(e8f5e9 / 4CAF50) 
         * 改为 中立的石板灰色(eceff1 / 607d8b)
         * 以此区分“自动整定”的绿色和“手动运行”的蓝色
         */
        .result-box {
            background-color: #eceff1; /* 中性的浅灰蓝色 */
            border-color: #607d8b;     /* 中性的石板灰 */
        }
        /* --- 结束 V0.9.0 修改 --- */


        .result-box h4 {
            margin-top: 0;
        }

        .result-box i {
            font-size: 0.9em;
            color: #555;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            animation: spin 1.5s linear infinite;
            margin-top: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>

<body>

    <h1>PID在线仿真与自动整定器 v0.9.0</h1>

    <div class="container">
        <div class="controls">
            <h3>A. 仿真输入区</h3>
            
            <strong>1. 控制器参数 (PID)</strong>
            <p>
                Kc (增益): <input type="number" id="kc" value="1.0" step="0.1">
            </p>
            <p>
                Ti (积分时间,s): <input type="number" id="ti" value="9999" step="0.1"> (9999表示无穷大)
            </p>
            <p>
                Td (微分时间,s): <input type="number" id="td" value="0.0" step="0.1">
            </p>
            
            <strong>2. 被控对象 (Process)</strong>
            <div id="model-selection">
                <input type="radio" id="model1" name="model" value="first_order" checked>
                <label for="model1">一阶对象: 1/(5s+1)</label>
                <br>
                <input type="radio" id="model2" name="model" value="second_order">
                <label for="model2">二阶对象: 25/(s²+3s+25)</label>
            </div>
            
            <p>
                纯滞后 (Delay,s): <input type="number" id="delay" value="0.0" step="0.1">
            </p>

            <strong>3. 仿真设置</strong>
            <p>
                仿真时间 (s): <input type="number" id="sim-time" value="50" step="1" min="10">
            </p>


            <h3>B. 仿真控制区</h3>
            <button id="run-button">运行仿真 (手动)</button>
            <button id="autotune-button">参数自动整定 (Auto-Tune)</button>
            
            <div id="autotune-status" class="status-box hidden">
                <p><strong>正在自动整定...</strong></p>
                <p id="autotune-step-info">请稍候...</p> 
                <div class="spinner"></div>
            </div>
            
            <div id="autotune-results" class="result-box hidden">
                <h4>参数结果:</h4>
                <p id="autotune-result-params"></p>
                <p><i>...</i></p>
            </div>

        </div>

        <div class="plot-area">
            <h3>C. 仿真输出区</h3>
            <div id="plot"></div>
        </div>
    </div>

    <script>
        // --- "大脑" (app.js) V9.0 改进版 ---
        console.log("app.js (大脑) V9.0 改进版 已加载!");

        // --- 1. 获取HTML元素 ---
        const runButton = document.getElementById("run-button"); const autotuneButton = document.getElementById("autotune-button");
        const plotDiv = document.getElementById("plot"); const kcInput = document.getElementById("kc"); const tiInput = document.getElementById("ti"); const tdInput = document.getElementById("td"); const delayInput = document.getElementById("delay");
        const autotuneStatusDiv = document.getElementById("autotune-status"); const autotuneStepInfo = document.getElementById("autotune-step-info");
        const autotuneResultsDiv = document.getElementById("autotune-results"); const autotuneResultParams = document.getElementById("autotune-result-params");
        const simTimeInput = document.getElementById("sim-time"); 
        
        // --- (V8.7) 获取模型选择元素 ---
        const model1Radio = document.getElementById("model1");
        const model2Radio = document.getElementById("model2");
        // --- 结束V8.7 ---

        // --- 2. 仿真核心参数 & 3. G2模型 ---
        const SIM = { sampleTime: 0.01, spStartTime: 5, spStartValue: 0.0, spEndValue: 1.0, };
        const OP_MIN = 0.0; const OP_MAX = 2.0; const PID_N = 10.0;
        const G2 = { Ad: [[0.99876266, 0.00984738], [-0.24618462, 0.96922051]], Bd: [[0.00123734], [0.24618462]], C: [1, 0] };

        // --- 4. 事件监听器 ---
        runButton.addEventListener("click", runSimulation);
        
        autotuneButton.addEventListener("click", async function () {
            
            let newTotalTime = parseFloat(simTimeInput.value);
            if (isNaN(newTotalTime) || newTotalTime < 10) {
                newTotalTime = 50.0;
                simTimeInput.value = "50";
            }

            autotuneButton.disabled = true; runButton.disabled = true;
            autotuneResultsDiv.classList.add("hidden"); 
            autotuneStatusDiv.classList.remove("hidden");
            try {
                const autoTuner = new AutoTuner();
                const bestParams = await autoTuner.runOptimization();
                autotuneStatusDiv.classList.add("hidden");
                await new Promise(resolve => setTimeout(resolve, 400));
                
                // --- 【V8.8 逻辑】 自动整定时，设置结果框的标题和说明 ---
                const resultBoxTitle = autotuneResultsDiv.querySelector("h4");
                const resultBoxCaption = autotuneResultsDiv.querySelector("i");
                if (resultBoxTitle) resultBoxTitle.textContent = "自动整定结果:";
                if (resultBoxCaption) resultBoxCaption.textContent = "参数已自动回填，仿真曲线已更新。";
                // --- 结束 V8.8 逻辑 ---

                autotuneResultsDiv.classList.remove("hidden"); 
                const { Kc, Ti } = bestParams;
                autotuneResultParams.innerHTML = `<b>优化结果: Kc=${Kc.toFixed(3)}, Ti=${Ti.toFixed(3)}, Td=0.0</b>`;
                kcInput.value = Kc.toFixed(3); tiInput.value = Ti.toFixed(3); tdInput.value = 0.0;
                
                runSimulation(); 
                
            } catch (error) {
                autotuneStatusDiv.classList.add("hidden");
                alert(`响应优化失败: ${error.message}`);
                initializeChart();

            } finally {
                autotuneButton.disabled = false; runButton.disabled = false;
            }
        });

        // --- (V8.7) 当被控对象参数变化时，隐藏旧的整定结果 ---
        function hideStaleResults() {
            if (!autotuneResultsDiv.classList.contains("hidden")) {
                console.log("被控对象参数已更改，隐藏旧的整定结果。");
                autotuneResultsDiv.classList.add("hidden");
            }
        }
        
        model1Radio.addEventListener("change", hideStaleResults);
        model2Radio.addEventListener("change", hideStaleResults);
        delayInput.addEventListener("change", hideStaleResults);
        // --- 结束 V8.7 ---


        // --- 【V8.9 逻辑】 页面加载时初始化一个空图表 ---
        function initializeChart() {
            console.log("初始化空图表...");
            
            const pvColor = '#1f77b4'; const opColor = '#d62728'; const spColor = 'black';
            const sp_trace = { x: [], y: [], mode: 'lines', name: 'SP (设定值)', line: { color: spColor, dash: 'dash' } };
            const pv_trace = { x: [], y: [], mode: 'lines', name: 'PV (过程值)', line: { color: pvColor, width: 2.5 } };
            const op_trace = { 
                x: [], 
                y: [], 
                mode: 'lines', 
                name: 'OP (控制器输出)', 
                line: { color: opColor }, 
                yaxis: 'y2',
                visible: 'legendonly' 
            };
            
            const layout = { 
                title: 'PID 仿真响应曲线',
                plot_bgcolor: '#f7f7f7', 
                paper_bgcolor: '#ffffff', 
                xaxis: { 
                    title: '时间 (s)',
                    gridcolor: '#e0e0e0', 
                    gridwidth: 1,
                    griddash: 'dot',
                    range: [0, parseFloat(simTimeInput.value) || 50] 
                }, 
                yaxis: { 
                    title: {
                        text: 'PV / SP',
                        font: { color: pvColor, size: 14 }
                    }, 
                    range: [-0.2, 1.5], 
                    tickfont: { color: pvColor },
                    gridcolor: '#e0e0e0',
                    gridwidth: 1,
                    griddash: 'dot'
                }, 
                yaxis2: { 
                    title: {
                        text: 'OP',
                        font: { color: opColor, size: 14 }
                    }, 
                    overlaying: 'y', 
                    side: 'right', 
                    range: [-0.28, OP_MAX + 0.1], 
                    tickfont: { color: opColor },
                    showgrid: false,
                    visible: false 
                }, 
                legend: { 
                    x: 0.5, 
                    y: 1.1,
                    xanchor: 'center',
                    orientation: 'h' 
                },
                margin: { l: 60, r: 60, t: 80, b: 50 }
            };
            
            Plotly.newPlot(plotDiv, [sp_trace, pv_trace, op_trace], layout);

            // --- 【V8.6 逻辑】添加图例点击事件监听器 ---
            plotDiv.removeAllListeners('plotly_legendclick'); 
            plotDiv.on('plotly_legendclick', function(data) {
                if (data.curveNumber === 2) { 
                    const currentVisibility = data.fullData[2].visible;
                    let newAxisVisibility;
                    if (currentVisibility === 'legendonly') {
                        newAxisVisibility = true;
                    } else {
                        newAxisVisibility = false; 
                    }
                    Plotly.relayout(plotDiv, { 'yaxis2.visible': newAxisVisibility });
                }
                return true; 
            });
            // --- 结束 V8.6 逻辑 ---
        }
        // --- 结束 V8.9 逻辑 ---


        // --- 5. 核心仿真函数 & 6. 辅助工具 ---
        function runSimulation() {
            console.log("开始仿真...");

            // --- 【V8.3】Ti参数验证 ---
            let Ti = parseFloat(tiInput.value);
            if (Ti <= 0) {
                alert("积分时间 (Ti) 必须大于 0。\n如果想关闭积分，请输入 9999。\n已自动重置为 9999。");
                Ti = 9999.0;
                tiInput.value = "9999";
            }

            // --- 【V8.4】Kc参数验证 ---
            let Kc = parseFloat(kcInput.value); 
            if (Kc <= 0) {
                 alert("控制器增益 (Kc) 必须大于 0。\nKc=0 将导致控制器无输出。\n已自动重置为 1.0。");
                 Kc = 1.0;
                 kcInput.value = "1.0";
            }
            // --- 结束 V8.4 ---

            const Td = parseFloat(tdInput.value);
            const delayTime = parseFloat(delayInput.value); 
            const selectedModel = document.querySelector('input[name="model"]:checked').value;

            // --- 【V8.8 逻辑】 更新结果框显示 ---
            autotuneStatusDiv.classList.add("hidden");
            const resultBoxTitle = autotuneResultsDiv.querySelector("h4");
            const resultBoxCaption = autotuneResultsDiv.querySelector("i");
            
            // 检查触发 runSimulation 的是不是“自动整定”按钮
            // 如果是“自动整定”调用的，按钮会是 disabled 状态 (V8.9 修正逻辑)
            if (autotuneButton.disabled === false) {
                // 只有当用户点击“手动运行”时，才修改标题为“手动”
                if (resultBoxTitle) resultBoxTitle.textContent = "当前手动参数:";
                autotuneResultParams.innerHTML = `<b>Kc=${Kc.toFixed(3)}, Ti=${Ti.toFixed(3)}, Td=${Td.toFixed(3)}</b>`;
                if (resultBoxCaption) resultBoxCaption.textContent = "仿真曲线已按此参数更新。";
            }
            
            autotuneResultsDiv.classList.remove("hidden");
            // --- 结束 V8.8 逻辑 ---


            let totalTime = parseFloat(simTimeInput.value);
            if (isNaN(totalTime) || totalTime < 10) {
                totalTime = 50.0;
                simTimeInput.value = "50";
            }
            const numSteps = Math.floor(totalTime / SIM.sampleTime);

            const delaySteps = Math.round(delayTime / SIM.sampleTime);
            const delayBuffer = new DelayBuffer(delaySteps);
            let timeData = [], spData = [], pvData = [], opData = [];
            let pidState = { integral: 0.0, derivative_filtered: 0.0 };
            let g1_pv_prev = 0.0; let g2_x = [0.0, 0.0]; let pv = 0.0; let pv_prev = 0.0; let op = 0.0;
            
            for (let k = 0; k < numSteps; k++) {
                let t = k * SIM.sampleTime;
                if (selectedModel === 'first_order') {
                    let a = Math.exp(-SIM.sampleTime / 5.0); let b = 1.0 * (1.0 - a); pv = a * g1_pv_prev + b * op; g1_pv_prev = pv;
                } else {
                    let x_prev = [...g2_x];
                    let x0 = G2.Ad[0][0] * x_prev[0] + G2.Ad[0][1] * x_prev[1] + G2.Bd[0][0] * op;
                    let x1 = G2.Ad[1][0] * x_prev[0] + G2.Ad[1][1] * x_prev[1] + G2.Bd[1][0] * op;
                    g2_x = [x0, x1]; pv = G2.C[0] * g2_x[0];
                }
                let sp = (t >= SIM.spStartTime) ? SIM.spEndValue : SIM.spStartValue;
                let op_raw = calculatePID(pidState, sp, pv, pv_prev, Kc, Ti, Td, OP_MIN, OP_MAX);
                let op_delayed = delayBuffer.push(op_raw);
                timeData.push(t); spData.push(sp); pvData.push(pv); opData.push(op_delayed);
                pv_prev = pv; op = op_delayed;
            }
            
            // --- 曲线定义 ---
            const pvColor = '#1f77b4'; const opColor = '#d62728'; const spColor = 'black';
            const sp_trace = { x: timeData, y: spData, mode: 'lines', name: 'SP (设定值)', line: { color: spColor, dash: 'dash' } };
            const pv_trace = { x: timeData, y: pvData, mode: 'lines', name: 'PV (过程值)', line: { color: pvColor, width: 2.5 } };
            
            // --- 【V8.4】设置OP线默认隐藏 ---
            const op_trace = { 
                x: timeData, 
                y: opData, 
                mode: 'lines', 
                name: 'OP (控制器输出)', 
                line: { color: opColor }, 
                yaxis: 'y2',
                visible: 'legendonly' 
            };
            // --- 结束 V8.4 ---
            
            // --- 布局定义 (美化修改) ---
            const layout = { 
                title: 'PID 仿真响应曲线',
                plot_bgcolor: '#f7f7f7', 
                paper_bgcolor: '#ffffff', 
                xaxis: { 
                    title: '时间 (s)',
                    gridcolor: '#e0e0e0', 
                    gridwidth: 1,
                    griddash: 'dot',
                    range: [0, totalTime] // 【V8.9 改进】确保X轴范围与仿真时间匹配
                }, 
                yaxis: { 
                    title: {
                        text: 'PV / SP',
                        font: { color: pvColor, size: 14 }
                    }, 
                    range: [-0.2, 1.5], 
                    tickfont: { color: pvColor },
                    gridcolor: '#e0e0e0',
                    gridwidth: 1,
                    griddash: 'dot'
                }, 
                yaxis2: { 
                    title: {
                        text: 'OP',
                        font: { color: opColor, size: 14 }
                    }, 
                    overlaying: 'y', 
                    side: 'right', 
                    range: [-0.28, OP_MAX + 0.1], 
                    tickfont: { color: opColor },
                    showgrid: false,
                    visible: false 
                }, 
                legend: { 
                    x: 0.5, 
                    y: 1.1,
                    xanchor: 'center',
                    orientation: 'h' 
                },
                margin: { l: 60, r: 60, t: 80, b: 50 }
            };
            
            Plotly.newPlot(plotDiv, [sp_trace, pv_trace, op_trace], layout);

            // --- 【V8.6 逻辑】添加图例点击事件监听器 ---
            plotDiv.removeAllListeners('plotly_legendclick'); 
            plotDiv.on('plotly_legendclick', function(data) {
                if (data.curveNumber === 2) { 
                    const currentVisibility = data.fullData[2].visible;
                    let newAxisVisibility;

                    if (currentVisibility === 'legendonly') {
                        newAxisVisibility = true;
                    } else {
                        newAxisVisibility = false; 
                    }
                    Plotly.relayout(plotDiv, { 'yaxis2.visible': newAxisVisibility });
                }
                return true; 
            });
            // --- 结束 V8.6 逻辑 ---
        }

        class DelayBuffer {
            constructor(delaySteps) { this.buffer = new Array(delaySteps).fill(0.0); }
            push(value) { if (this.buffer.length === 0) return value; const delayedValue = this.buffer.shift(); this.buffer.push(value); return delayedValue; }
        }

        function calculatePID(state, sp, pv, pv_prev, Kc, Ti, Td, op_min, op_max) {
            let dt = SIM.sampleTime; let error = sp - pv; 
            let P_out = Kc * error; 
            let I_out = (Ti > 0 && Ti < 9998) ? state.integral : 0.0; 
            let D_out = 0.0;
            if (Td > 0) {
                let T_f = Td / PID_N; if (T_f < dt) T_f = dt; let a = T_f / (T_f + dt);
                let derivative_raw = (pv - pv_prev) / dt;
                state.derivative_filtered = a * state.derivative_filtered + (1 - a) * derivative_raw;
                D_out = -Kc * Td * state.derivative_filtered; 
            } else { state.derivative_filtered = 0.0; }
            let op_unclamped = P_out + I_out + D_out; 
            let op_clamped = Math.max(op_min, Math.min(op_max, op_unclamped));
            if (Ti > 0 && Ti < 9998) {
                let is_winding_up = (op_clamped >= op_max && error > 0); 
                let is_winding_down = (op_clamped <= op_min && error < 0);
                if (!is_winding_up && !is_winding_down) { state.integral += (Kc / Ti) * error * dt; }
            } else { state.integral = 0.0; }
            return op_clamped;
        }

        // --- 7. 响应优化器核心实现 V8.1 (未修改) ---
        class AutoTuner {
            constructor() {
                this.delayTime = parseFloat(delayInput.value); 
                this.selectedModel = document.querySelector('input[name="model"]:checked').value;
                this.totalTime = parseFloat(simTimeInput.value);
                if (isNaN(this.totalTime) || this.totalTime < 10) {
                    this.totalTime = 50.0;
                }
                this.maxIterations = 100; this.tolerance = 1e-6;
            }
            async runOptimization() {
                return new Promise(async (resolve, reject) => {
                    try {
                        const stage1StartTime = Date.now();
                        autotuneStepInfo.innerHTML = `步骤 1/2: 识别近似模型...`;
                        await this.forceUIRender();
                        const initialGuess = this._getInitialGuess();
                        console.log("Initial Guess:", initialGuess);
                        const stage1Duration = Date.now() - stage1StartTime;
                        if (stage1Duration < 800) await new Promise(res => setTimeout(res, 800 - stage1Duration));
                        autotuneStepInfo.innerHTML = `步骤 2/2: 进行响应优化...`;
                        await this.forceUIRender();
                        const bestPoint = await this._performOptimization(initialGuess);
                        resolve({ Kc: bestPoint.kc, Ti: bestPoint.ti });
                    } catch (e) { reject(e); }
                });
            }
            async _performOptimization(initialGuess) {
                let p1 = { kc: initialGuess.Kc, ti: initialGuess.Ti, cost: Infinity };
                let p2 = { kc: initialGuess.Kc * 1.5, ti: initialGuess.Ti, cost: Infinity };
                let p3 = { kc: initialGuess.Kc, ti: initialGuess.Ti * 0.7, cost: Infinity };
                let simplex = [p1, p2, p3];
                for (let p of simplex) { p.cost = this._evaluateCost(p.kc, p.ti); }
                let overallBest = simplex.sort((a,b)=>a.cost-b.cost)[0];
                let noImprovementCount = 0;
                for (let i = 0; i < this.maxIterations; i++) {
                    simplex.sort((a, b) => a.cost - b.cost);
                    let b = simplex[0], g = simplex[1], w = simplex[2];
                    if (b.cost < overallBest.cost) { overallBest = { ...b }; noImprovementCount = 0; } else { noImprovementCount++; }
                    autotuneStepInfo.innerHTML = `步骤 2/2: 优化迭代中... (${i + 1}/${this.maxIterations})<br>当前最优成本: ${overallBest.cost.toExponential(3)}`;
                    await this.forceUIRender(10);
                    if (Math.abs(b.cost - w.cost) < this.tolerance || noImprovementCount > 20) {
                        if(noImprovementCount > 20) console.log("优化停滞，提前终止。");
                        else console.log(`优化收敛于第 ${i+1} 次迭代。`);
                        break;
                    }
                    if (noImprovementCount > 15) {
                        console.log("陷入局部最优，进行随机重启...");
                        simplex[1] = { kc: overallBest.kc * (1 + Math.random() - 0.5), ti: overallBest.ti * (1 + Math.random() - 0.5) };
                        simplex[2] = { kc: overallBest.kc * (1 + Math.random() - 0.5), ti: overallBest.ti * (1 + Math.random() - 0.5) };
                        simplex[1].cost = this._evaluateCost(simplex[1].kc, simplex[1].ti);
                        simplex[2].cost = this._evaluateCost(simplex[2].kc, simplex[2].ti);
                        noImprovementCount = 0;
                        continue;
                    }
                    let centroid = { kc: (b.kc + g.kc) / 2, ti: (b.ti + g.ti) / 2 };
                    let reflected = { kc: centroid.kc + 1.0 * (centroid.kc - w.kc), ti: centroid.ti + 1.0 * (centroid.ti - w.ti) };
                    reflected.cost = this._evaluateCost(reflected.kc, reflected.ti);
                    if (reflected.cost < g.cost && reflected.cost >= b.cost) { simplex[2] = reflected; continue; }
                    if (reflected.cost < b.cost) {
                        let expanded = { kc: centroid.kc + 2.0 * (reflected.kc - centroid.kc), ti: centroid.ti + 2.0 * (reflected.ti - centroid.ti) };
                        expanded.cost = this._evaluateCost(expanded.kc, expanded.ti);
                        simplex[2] = expanded.cost < reflected.cost ? expanded : reflected; continue;
                    }
                    let contracted = { kc: centroid.kc + 0.5 * (w.kc - centroid.kc), ti: centroid.ti + 0.5 * (w.ti - centroid.ti) };
                    contracted.cost = this._evaluateCost(contracted.kc, contracted.ti);
                    if (contracted.cost < w.cost) { simplex[2] = contracted; continue; }
                    simplex[1] = { kc: b.kc + 0.5 * (g.kc - b.kc), ti: b.ti + 0.5 * (g.ti - b.ti) };
                    simplex[2] = { kc: b.kc + 0.5 * (w.kc - b.kc), ti: b.ti + 0.5 * (w.ti - b.ti) };
                    simplex[1].cost = this._evaluateCost(simplex[1].kc, simplex[1].ti);
                    simplex[2].cost = this._evaluateCost(simplex[2].kc, simplex[2].ti);
                }
                return overallBest;
            }
            _evaluateCost(Kc, Ti) {
                if (Kc <= 0.01 || Ti <= 0.05) return Infinity; 
                let sp_vec = [], pv_vec = [], op_vec = [];
                const delaySteps = Math.round(this.delayTime / SIM.sampleTime); const delayBuffer = new DelayBuffer(delaySteps);
                let pidState = { integral: 0.0, derivative_filtered: 0.0 };
                let g1_pv_prev = 0.0; let g2_x = [0.0, 0.0]; let pv = 0.0; let pv_prev = 0.0; let op = 0.0;
                const numSteps = Math.floor(this.totalTime / SIM.sampleTime); 
                for (let k = 0; k < numSteps; k++) {
                    let t = k * SIM.sampleTime;
                    if (this.selectedModel === 'first_order') {
                        let a = Math.exp(-SIM.sampleTime / 5.0); let b = 1.0 * (1.0 - a); pv = a * g1_pv_prev + b * op; g1_pv_prev = pv;
                    } else {
                        let x_prev = [...g2_x];
                        let x0 = G2.Ad[0][0] * x_prev[0] + G2.Ad[0][1] * x_prev[1] + G2.Bd[0][0] * op;
                        let x1 = G2.Ad[1][0] * x_prev[0] + G2.Ad[1][1] * x_prev[1] + G2.Bd[1][0] * op;
                        g2_x = [x0, x1]; pv = G2.C[0] * g2_x[0];
                    }
                    let sp = (t >= SIM.spStartTime) ? SIM.spEndValue : SIM.spStartValue;
                    let op_raw = calculatePID(pidState, sp, pv, pv_prev, Kc, Ti, 0.0, OP_MIN, OP_MAX);
                    op = delayBuffer.push(op_raw);
                    sp_vec.push(sp); pv_vec.push(pv); op_vec.push(op); pv_prev = pv;
                }
                let ita_error = 0, overshoot = 0, op_change = 0, settling_time_cost = 0;
                const startIndex = Math.floor(SIM.spStartTime / SIM.sampleTime); let settled = false;
                for (let i = startIndex; i < numSteps; i++) {
                    let error = sp_vec[i] - pv_vec[i];
                    let time_since_step = (i - startIndex) * SIM.sampleTime;
                    ita_error += time_since_step * Math.abs(error) * SIM.sampleTime;
                    if (error < -0.01) { overshoot = Math.max(overshoot, -error); }
                    if (i > startIndex) { op_change += Math.abs(op_vec[i] - op_vec[i - 1]); }
                    if (!settled && Math.abs(error) < 0.02) { settled = true; }
                    if (!settled) { settling_time_cost += SIM.sampleTime; }
                }
                if (pv_vec.some(v => isNaN(v) || Math.abs(v) > 5)) return Infinity;
                const cost = ita_error * 1.0 + overshoot * 20.0 + settling_time_cost * 0.5 + op_change * 0.1;
                return cost;
            }
            async forceUIRender(delay = 0) { await new Promise(resolve => setTimeout(resolve, delay)); }
            _getInitialGuess() {
                const stepResponseData = this._performStepTest();
                const model = this._identifyModel(stepResponseData);
                return this._calculateInitialParams(model);
            }
            _performStepTest() {
                const stepTime=2.0, stepStartOP=0.4, stepEndOP=0.6; let pvData = [];
                const delaySteps = Math.round(this.delayTime / SIM.sampleTime); const delayBuffer = new DelayBuffer(delaySteps);
                let g1_pv_prev = 0.0; let g2_x = [0.0, 0.0]; let pv = 0.0; let op;
                const numSteps = Math.floor(this.totalTime / SIM.sampleTime); 
                for (let k = 0; k < numSteps; k++) {
                    let t = k * SIM.sampleTime;
                    let current_op = (t >= stepTime) ? stepEndOP : stepStartOP;
                    op = delayBuffer.push(current_op);
                    if (this.selectedModel === 'first_order') {
                        let a = Math.exp(-SIM.sampleTime / 5.0); let b = 1.0 * (1.0 - a); pv = a * g1_pv_prev + b * op; g1_pv_prev = pv;
                    } else {
                        let x_prev = [...g2_x];
                        let x0 = G2.Ad[0][0] * x_prev[0] + G2.Ad[0][1] * x_prev[1] + G2.Bd[0][0] * op;
                        let x1 = G2.Ad[1][0] * x_prev[0] + G2.Ad[1][1] * x_prev[1] + G2.Bd[1][0] * op;
                        g2_x = [x0, x1]; pv = G2.C[0] * g2_x[0];
                    }
                    pvData.push(pv);
                }
                return pvData;
            }
            _identifyModel(pvData) {
                const stepTime=2.0, stepStartOP=0.4, stepEndOP=0.6;
                const delta_OP = stepEndOP - stepStartOP; const stepStartIndex = Math.floor(stepTime / SIM.sampleTime);
                const pv_start = pvData[stepStartIndex - 2];
                const pv_end_segment = pvData.slice(Math.floor(pvData.length * 0.8));
                const pv_end = pv_end_segment.reduce((a, b) => a + b, 0) / pv_end_segment.length;
                const delta_PV = pv_end - pv_start;
                if (Math.abs(delta_OP) < 1e-6 || Math.abs(delta_PV) < 1e-6) throw new Error("阶跃响应变化过小。");
                const Kp = delta_PV / delta_OP; let maxSlope = 0; let maxSlopeIndex = -1;
                for (let i = stepStartIndex; i < pvData.length -1; i++) {
                    const slope = (pvData[i] - pvData[i - 1]) / SIM.sampleTime;
                    if (slope > maxSlope) { maxSlope = slope; maxSlopeIndex = i; }
                }
                if (maxSlopeIndex === -1) throw new Error("未能找到响应曲线的上升段。");
                const pv_at_max_slope = pvData[maxSlopeIndex]; const t_at_max_slope = maxSlopeIndex * SIM.sampleTime;
                const t_intersect = t_at_max_slope - (pv_at_max_slope - pv_start) / maxSlope;
                const Theta = Math.max(0, t_intersect - stepTime); const Tau = delta_PV / maxSlope;
                return { Kp, Tau, Theta };
            }
            _calculateInitialParams(model) {
                const { Kp, Tau, Theta } = model;
                let Kc, Ti;
                if (Theta / Tau < 0.1 || Tau <= 0) {
                    const Lambda = Math.max(0.8 * Tau, 1.2 * Theta);
                    Kc = (1 / Kp) * Tau / (Lambda + Theta); Ti = Tau;
                } else {
                    Kc = (1 / Kp) * (Tau / Theta) * (0.9 + Theta / (12 * Tau));
                    Ti = Theta * (30 * Tau + 3 * Theta) / (9 * Tau + 20 * Theta);
                }
                return { Kc: Math.max(0.05, Kc), Ti: Math.max(0.1, Ti) };
            }
        }
        
        // --- 【V8.9 逻辑】页面加载后初始化空图表 ---
        window.onload = initializeChart;
    </script>

    <footer style="text-align: center; margin-top: 30px; color: #888; font-size: 0.9em;">
        <p>&copy; 2025 太原理工大学 化学与化工学院过控系 周文晋，张玮. All Rights Reserved.</p>
        <p>本仿真平台仅供教学演示使用，未经许可，请勿用于商业目的。</p>
    </footer>

</body>
</html>